## 스프링은...

### 스프링은 프레임워크이다.

### 스프링은 오픈소스이다.

소스코드를 공개하고 있고, 누구든 Contribution할 수 있음.

### IoC 컨테이너

`IoC(Inversion of Control), 제어의 역전`

`주도권이 스프링에 있다.`

특정 Object를 정의하고 Instance를 생성할 때

```java
public void make() {
    Obj obj = new Obj;    
}

public void use() {
    //위 코드의 obj를 사용하려면?    
}
```

`make()`메서드를 통해 Heap에 obj변수가 생기고 new를 통해 생성한 객체의 주소값을 갖는다.

`use()` 메서드에서 Obj라는 객체를 생성하더라도, 별개의 인스턴스가 될 것이며, 위 인스턴스를 가져다 사용하려면 매우 까다롭다.

스프링은 우리가 객체를 정의하기만 하면, Heap영역에 자동으로 인스턴스를 생성해주고 관리한다.


### DI

Di(Dependency Injection) : 의존성 주입

위에서 생성한 인스턴스들을 우리가 프로젝트 내 어디서든 가져다 사용할 수 있도록 해주는 것

스프링이 관리하는 HEAP영역에 생성된 인스턴스는 특정 객체에 의해 딱 한번만 생성된다.(`싱글톤`) 우리는 그 인스턴스를 어디서든 다룰 수 있게 된다.

### 수많은 필터들 존재

스프링에는 앱에 대한 접근과 관련해 수많은 필터가 존재해 그대로 사용할 수 있고, 필터 기능을 켜거나 끄게 할 수 있으며, 직접 필터를 생성할 수도 있다.

`톰캣이 가지고 있는 필터`는 `filter`라고 부르고, 해당 기능을 하고 있는 web.xml이라는 파일이 있다.

`스프링 컨테이너가 가지고 있는 필터`는 `interceptor`라고 한다.<br>
인터셉터도 filter와 비슷한 기능을 한다. 스프링 컨테이너에 접근하는 것에 대해 권한을 체크하여 내/외부로의 접근을 제어한다.

### 수많은 어노테이션 존재 (reflection, 컴파일체크)

일반적으로 컴파일러가 무시하는 comment-out annotation(주석) 과는 달리, '@'를 이용한 어노테이션은 컴파일러가 무시하지 않는다.

상속을 할 때, @Override와 같은 어노테이션을 많이 붙였는데, 표시만을 위해서만 붙이는 게 아니라, 컴파일 시 해당 어노테이션을 붙인 메소드가 실제로 재정의 되고 있는지 추적해서 확인을 한다.

> `스프링에서는 어노테이션을 이용해 객체 생성`을 한다.
> @Component → 클래스를 메모리에 로딩<br>
> @Autowired → 로딩된 객체를 해당 변수에 집어 넣음<br>
> @Controller<br>
> ...

```java
@Component
class A {
    
}
```
IoC 개념으로 인해, 우리는 객체 A에 대한 정의만 할 뿐, 우리가 직접 new를 통해서 인스턴스를 생성해 사용하기 보다는 다음과 같은 순서로 객체가 생성된다.

1. 스프링이 어노테이션을 확인.
2. 해당 클래스를 스캔해서 스프링이 관리하는 특정 메모리 `Heap에 A클래스를 로드`
3. 사용자가 해당 클래스를 사용할 곳을 정의
```java
class B {
//    A a = new A();
    @Autowired
    A a;
}
```
4. 스프링이 B클래스를 스캔할 때, B클래스 내부에 어떠한 것이 있는지 분석 (해당 분석 기법을 `reflection`이라고 함)<br>
5. reflection을 통해 어떤 특정 클래스 내부에 있는, 메서드, 필드, 어노테이션 등을 체크 및 그에 대한 행동 정의 
6. 위와 같은 코드의 경우, 스프링이 메모리 `Heap에 존재하는 클래스를 모두 스캔`, `A타입의 존재 여부 확인`.
7-1. 존재하지 않는 경우, `A a = null`;
7-2. 존재하는 경우, `Heap의 A객체가 a변수로 들어감` (a가 해당 메모리를 가리키게 됨) : `DI` 
    
`어노테이션` : `주석 + 힌트`

`reflection` : `분석하는 기법 → 런타임시 분석`